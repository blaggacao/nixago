<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nixago</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">1.1.</strong> Quick Start</a></li></ol></li><li class="chapter-item expanded "><a href="plugins/index.html"><strong aria-hidden="true">2.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugins/conform.html"><strong aria-hidden="true">2.1.</strong> Conform</a></li><li class="chapter-item expanded "><a href="plugins/just.html"><strong aria-hidden="true">2.2.</strong> Just</a></li><li class="chapter-item expanded "><a href="plugins/lefthook.html"><strong aria-hidden="true">2.3.</strong> Lefthook</a></li><li class="chapter-item expanded "><a href="plugins/pre-commit.html"><strong aria-hidden="true">2.4.</strong> Pre-commit</a></li><li class="chapter-item expanded "><a href="plugins/prettier.html"><strong aria-hidden="true">2.5.</strong> Prettier</a></li></ol></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">3.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/design.html"><strong aria-hidden="true">3.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="contributing/plugins.html"><strong aria-hidden="true">3.2.</strong> Plugins</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nixago</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Nixago is a <a href="https://nixos.wiki/wiki/Flakes">flake</a> library that aims to simplify managing the various
configuration files built up at the root of your repositories. Its plugin-based
approach makes it easy to extend to cover any development tool you may use
across your projects. It allows your <code>flake.nix</code> to serve as the central source
of truth for configuring your development tools.</p>
<p>Underneath the hood, Nixago uses <a href="https://nixos.org/">Nix</a> and <a href="https://cuelang.org/">Cue</a> for generating
configuration files. It's designed to be used in tandem with a <a href="https://nixos.org/manual/nix/stable/command-ref/nix-shell.html">nix shell</a> to
dynamically create and manage configuration files in your existing development
environments. All that's required is defining the configurations in the
<code>flake.nix</code> file at the root of your repository, and Nixago will automatically
generate shell hooks that can be used to create and manage the files.</p>
<p>Don't see a plugin for your development tool? <a href="https://github.com/jmgilman/nixago/issues/new">Submit a new feature request</a>
or consider <a href="https://jmgilman.github.io/nixago/contributing/index.html">adding your own</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Nixago provides support for generating configurations for many different
development tools. Refer to the plugins section for a list of currently
supported tools or open up a new issue to request a tool be added.</p>
<h2 id="add-nixago-as-an-input"><a class="header" href="#add-nixago-as-an-input">Add Nixago as an Input</a></h2>
<p>The first step is adding Nixago as an input to your current <code>flake.nix</code>:</p>
<pre><code class="language-nix">{
  inputs = {
    # ...
    nixpkgs.url = &quot;github:nixos/nixpkgs&quot;;
    nixago.url = &quot;github:jmgilman/nixago&quot;;
    nixago.inputs.nixpkgs.follows = &quot;nixpkgs&quot;;
    # ...
  };
}
</code></pre>
<p>To maintain consistency in the packages being used across your <code>flake.nix</code>, it's
recommended to force Nixago's copy to follow the one declared in your flake.</p>
<h2 id="generate-a-configuration"><a class="header" href="#generate-a-configuration">Generate a Configuration</a></h2>
<p>Choose a plugin to use. The below example uses the plugin for <a href="https://pre-commit.com/">pre-commit</a>:</p>
<pre><code class="language-nix">{
# ...
    preCommitConfig = {
        nixpkgs-fmt = {
            entry = &quot;${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt&quot;;
            language = &quot;system&quot;;
            files = &quot;\\.nix&quot;;
        };
    };

    preCommit = nixago.plugins.pre-commit.mkLocalConfig {
        configData = preCommitConfig;
    };
# ...
}
</code></pre>
<p>The easiest way to integrate the generated configuration into your development
environment is to use the provided shell hook:</p>
<pre><code class="language-nix">{
# ...
    devShell = pkgs.mkShell {
        shellHook = nixago.lib.mkShellHook [ preCommit ];
    };
# ...
}
</code></pre>
<p>The hook will automatically link the file from the Nix store to the current
working directory. The above example will produce a <code>.pre-commit-config.yaml</code>
file with the following contents:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - entry: /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt
        files: \.nix
        id: nixpkgs-fmt
        language: system
        name: nixpkgs-fmt
    repo: local
</code></pre>
<h2 id="changing-output-path"><a class="header" href="#changing-output-path">Changing Output Path</a></h2>
<p>By default, the shell hook for each plugin will generate the configuration file
at the root of your repository (i.e., the location where <code>flake.nix</code> resides).
The file name and relative location can be modified:</p>
<pre><code class="language-nix">{
# ...
    preCommitConfig = {
        nixpkgs-fmt = {
            entry = &quot;${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt&quot;;
            language = &quot;system&quot;;
            files = &quot;\\.nix&quot;;
        };
    };

    preCommit = nixago.plugins.pre-commit.mkLocalConfig {
        configData = preCommitConfig;
        output = &quot;.config/pre-commit-config.yaml&quot;;
    };
# ...
}
</code></pre>
<p>The above example would place the configuration file in
<code>.config/pre-commit-config.yaml</code>.</p>
<h2 id="changing-generation-mode"><a class="header" href="#changing-generation-mode">Changing Generation Mode</a></h2>
<p>By default, the shell hook manages a symbolic link from the Nix store to the
output path. It automatically synchronizes any changes by updating the link if
the generated configuration file changes. This mode can be altered to instead
maintain a local copy of the generated configuration file. In this mode, the
shell hook compares the contents of the local copy to the one in the Nix store
and updates it accordingly. The primary benefit of this change is that it allows
the file to be checked into git, and if your Nix store is read-only, it can be
edited locally.</p>
<pre><code class="language-nix">{
# ...
    preCommitConfig = {
        nixpkgs-fmt = {
            entry = &quot;${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt&quot;;
            language = &quot;system&quot;;
            files = &quot;\\.nix&quot;;
        };
    };

    preCommit = nixago.plugins.pre-commit.mkLocalConfig {
        configData = preCommitConfig;
        mode = &quot;copy&quot;;
    };
# ...
}
</code></pre>
<h2 id="making-multiple-configurations"><a class="header" href="#making-multiple-configurations">Making Multiple Configurations</a></h2>
<p>A utility function is available for generating multiple configurations. The
following is an excerpt from the <code>flake.nix</code> that manages this project:</p>
<pre><code class="language-nix">{
# Define development tool configuration
    configurations = {
        # Just configuration
        &quot;just&quot; = {
            tasks = {
                check = [
                    &quot;@${tools.nixpkgs-fmt.exe} --check flake.nix $(git ls-files '**/*.nix')&quot;
                    &quot;@${tools.prettier.exe} --check .&quot;
                    &quot;@${tools.typos.exe}&quot;
                    &quot;@nix flake check&quot;
                ];
                check-docs = [
                    &quot;@${tools.typos.exe}&quot;
                ];
                make-docs = [
                    &quot;@cd docs &amp;&amp; mdbook build&quot;
                ];
                fmt = [
                    &quot;@${tools.nixpkgs-fmt.exe} flake.nix $(git ls-files '**/*.nix')&quot;
                    &quot;@${tools.prettier.exe} -w .&quot;
                ];
            };
        };
        # Lefthook configuration
        &quot;lefthook&quot; = {
        pre-commit = {
            commands = {
                nixpkgs-fmt = {
                    run = &quot;${tools.nixpkgs-fmt.exe} --check {staged_files}&quot;;
                    glob = &quot;*.nix&quot;;
                };
                prettier = {
                    run = &quot;${tools.prettier.exe} --check {staged_files}&quot;;
                    glob = &quot;*.{yaml,yml,md}&quot;;
                };
                typos = {
                    run = &quot;${tools.typos.exe} {staged_files}&quot;;
                };
            };
        };
        };
        # Prettier
        &quot;prettier.mkIgnoreConfig&quot; = [
            &quot;.direnv&quot;
            &quot;tests&quot;
            &quot;lefthook.yml&quot;
        ];
    };

    # ...

    # Local development shell
    devShells = {
        default = pkgs.mkShell {
            shellHook = (lib.mkAll configurations).shellHook;
            packages = tools.all;
        };
    };
}
</code></pre>
<p>The input to <code>mkAll</code> expects an attribute set where the name is one of the
following:</p>
<ol>
<li>A path to the function to be called, relative to the <code>plugins</code> set (i.e.,
<code>prettier.mkIgnoreConfig</code>)</li>
<li>The name of a plugin with <code>.opts</code> appended (i.e., <code>prettier.opts</code>)</li>
</ol>
<p>Appending the function name after the plugin name is optional. In this case, the
<code>mkAll</code> function will call the <code>default</code> function. This function is specific to
each plugin; refer to the source code for what is called.</p>
<p>The value of the attribute should be the raw configuration data that will be
passed to the function. All plugin functions take a <code>configData</code> argument which
contains the configuration data. This argument is supplied with the value of the
attribute.</p>
<p>The <code>default</code> function will be called from the plugin if none is provided. See
the individual plugins for which function this is. Most plugin functions accept
additional arguments beyond <code>configData</code>. To pass other arguments using the
<code>mkAll</code> function, you must add an extra attribute in the format of
<code>pluginName.opts</code>. The value of this attribute should be a set that will be
merged into the final call to the plugin function. The below example changes the
mode of the Prettier plugin:</p>
<pre><code class="language-nix">{
  # ...
  &quot;prettier.opts&quot; = {
    mode = &quot;copy&quot;;
  };
  # ...
}
</code></pre>
<p>The second parameter is the configuration to be passed. The result is an
attribute set with a unified <code>shellHook</code> attribute that contains all of the
logic for managing the configurations. This result makes adding additional
configuration files to your existing projects seamless.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Nixago provides most functionality through plugins. Each plugin targets a
specific configuration by providing a clean interface for end-users. While most
plugins follow a standard schema, the varying requirements of formats can
require minor differences.</p>
<p>Plugins are accessed via <code>nixago.plugins.${pluginName}</code>. See the relevant
documentation page or check the source code for what functions a plugin
provides.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="conform"><a class="header" href="#conform">Conform</a></h1>
<p>This plugin generates the <code>.conform.yaml</code> file for configuring <a href="https://github.com/siderolabs/conform">Conform</a>. It
provides a single function that takes a simplified version of the configuration
file:</p>
<ul>
<li>The top-level <code>policies</code> entry is removed</li>
<li>The <code>type</code> and <code>spec</code> sections of the policy are removed</li>
</ul>
<p>Instead, the function takes a set where the key is either <code>commit</code> or <code>license</code>
(the two valid policy types), and the value is what would typically get placed
under <code>spec</code>. This change reduces the overall nesting of the input.</p>
<p>Example input:</p>
<pre><code class="language-nix">{
  commit = {
    header = {
      length = 89;
      imperative = true;
      case = &quot;lower&quot;;
      invalidLastCharacters = &quot;.&quot;;
    };
    gpg = {
      required = false;
      identity = {
        gitHubOrganization = &quot;some-organization&quot;;
      };
    };
    conventional = {
      types = [
        &quot;type&quot;
      ];
      scopes = [
        &quot;scope&quot;
      ];
    };
  };
  license = {
    skipPaths = [
      &quot;.git/&quot;
      &quot;build*/&quot;
    ];
    allowPrecedingComments = false;
  };
}
</code></pre>
<p>This would produce the following <code>.conform.yaml</code> file:</p>
<pre><code class="language-yaml">policies:
  - spec:
      conventional:
        scopes:
          - scope
        types:
          - type
      gpg:
        identity:
          gitHubOrganization: some-organization
        required: false
      header:
        case: lower
        imperative: true
        invalidLastCharacters: .
        length: 89
    type: commit
  - spec:
      allowPrecedingComments: false
      skipPaths:
        - .git/
        - build*/
    type: license
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="just"><a class="header" href="#just">Just</a></h1>
<p>This plugin generates the <code>.just</code> file used by the <a href="https://github.com/casey/just">Just</a> task runner. It
provides a single function that allows you to declare a header section and
subsequent tasks/steps.</p>
<h2 id="using-mkconfig"><a class="header" href="#using-mkconfig">Using mkConfig</a></h2>
<pre><code class="language-nix">{
  just = plugins.just.mkConfig {
    config = {
      head = ''
        var := &quot;value&quot;
      '';
      tasks = {
        task1 = [
          ''echo &quot;Doing the thing&quot;''
          &quot;@doThing&quot;
        ];
      };
    };
  };
}
</code></pre>
<p>The configuration has two major sections. The first is the <code>header</code> field, a raw
string prepended to the top of the file. This section is typically where global
settings and variables are defined in the Justfile. The second is the <code>tasks</code>
field, a map of task names to a list of their respective steps. Each step in the
list should ideally encompass a single action (this is idiomatic for Justfiles);
however, multiline strings will also work.</p>
<p>The above example will produce the following file contents:</p>
<pre><code class="language-just">var := &quot;value&quot;

task1:
    echo &quot;Doing the thing&quot;
    @doThing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lefthook"><a class="header" href="#lefthook">Lefthook</a></h1>
<p>This plugin generates the <code>lefthook.yml</code> file for configuring <a href="https://github.com/evilmartians/lefthook">Lefthook</a>. It
provides a single function that allows configuring any of the <a href="https://github.com/evilmartians/lefthook/blob/master/docs/full_guide.md">valid
options</a>.</p>
<h2 id="using-mkconfig-1"><a class="header" href="#using-mkconfig-1">Using mkConfig</a></h2>
<pre><code class="language-nix">{
    config = {
        commit-msg = {
            scripts = {
                template_checker = { runner = &quot;bash&quot;; };
            };
        };
        pre-commit = {
            commands = {
                stylelint = {
                    tags = &quot;frontend style&quot;;
                    glob = &quot;*.js&quot;;
                    run = &quot;yarn stylelint {staged_files}&quot;;
                };
                rubocop = {
                    tags = &quot;backend style&quot;;
                    glob = &quot;*.rb&quot;;
                    exclude = &quot;application.rb|routes.rb&quot;;
                    run = &quot;bundle exec rubocop --force-exclusion {all_files}&quot;;
                };
            };
            scripts = {
                &quot;good_job.js&quot; = { runner = &quot;node&quot;; };
            };
        };
    };
}
</code></pre>
<p>Produces the following <code>lefthook.yml</code>:</p>
<pre><code class="language-yaml">commit-msg:
  scripts:
    template_checker:
      runner: bash
pre-commit:
  commands:
    rubocop:
      exclude: application.rb|routes.rb
      glob: &quot;*.rb&quot;
      run: bundle exec rubocop --force-exclusion {all_files}
      tags: backend style
    stylelint:
      glob: &quot;*.js&quot;
      run: yarn stylelint {staged_files}
      tags: frontend style
  scripts:
    good_job.js:
      runner: node
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-commit"><a class="header" href="#pre-commit">Pre-commit</a></h1>
<p>This plugin generates the <code>.pre-commit-config.yaml</code> file used to configure
<a href="https://pre-commit.com/">pre-commit</a>. It provides two functions for generating the configuration.</p>
<h2 id="using-mkconfig-2"><a class="header" href="#using-mkconfig-2">Using mkConfig</a></h2>
<p>The first function follows the <a href="https://pre-commit.com/#adding-pre-commit-plugins-to-your-project">structure described in the docs</a>:</p>
<pre><code class="language-nix">{
  pre-commit = nixago.plugins.pre-commit.mkConfig {
    config = {
      repos = [
        {
          repo = &quot;https://github.com/my/repo&quot;;
          rev = &quot;1.0&quot;;
          hooks = [
            {
              id = &quot;my-hook&quot;;
            }
          ];
        }
      ];
    };
  };
}
</code></pre>
<p>Cue validates the structure, and the derivation will fail to build if any
mistakes are found. The above configuration will create the following file
contents:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - id: my-hook
    repo: https://github.com/my/repo
    rev: &quot;1.0&quot;
</code></pre>
<h2 id="using-mklocalconfig"><a class="header" href="#using-mklocalconfig">Using mkLocalConfig</a></h2>
<p>The second function accepts a simplified configuration format that significantly
reduces the verbosity. When managing pre-commit with Nix, creating a single
&quot;local&quot; repo entry and adding system hooks that call out to binaries in the Nix
store is often desirable. The benefit of this approach is that Nix manages the
versioning of the binaries, and you have greater control over how the hook
operates.</p>
<p>The accepted format is as follows:</p>
<pre><code class="language-nix">{
    nixpkgs-fmt = {
        entry = &quot;${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt&quot;;
        language = &quot;system&quot;;
        files = &quot;\\.nix&quot;;
    }
}
</code></pre>
<p>The format is a set consisting of hook names as the keys and their configuration
properties as values. The <code>id</code> and <code>name</code> fields of the hook configuration are
set to the hook name (i.e., <code>nixpkgs-fmt</code>). The <code>entry</code> should point to the
binary called by pre-commit. Setting <code>language</code> to &quot;system&quot; ensures that the
<code>entry</code> is called with the default shell. Finally, setting <code>files</code> ensures that
pre-commit only passes Nix files to this hook. The above configuration would
produce the following <code>pre-commit-config.yaml</code> file:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - entry: /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt
        files: \.nix
        id: nixpkgs-fmt
        language: system
        name: nixpkgs-fmt
    repo: local
</code></pre>
<p>Notice how the <code>repos</code> and <code>repo</code> properties are set.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prettier"><a class="header" href="#prettier">Prettier</a></h1>
<p>This plugin generates the <code>.prettierrc.json</code> file for configuring <a href="https://prettier.io/">Prettier</a>.
It provides a single function that allows you to configure any valid API
options]<a href="https://prettier.io/docs/en/options.html">2</a>.</p>
<h2 id="using-mkconfig-3"><a class="header" href="#using-mkconfig-3">Using mkConfig</a></h2>
<p>The schema for the configuration file is <a href="https://prettier.io/docs/en/configuration.html">detailed here</a>. For example:</p>
<pre><code class="language-nix">{
    config = {
      arrowParens = &quot;always&quot;;
      bracketSpacing = true;
      tabWidth = 80;
    };
}
</code></pre>
<p>Produces the following <code>.prettierrc.json</code>:</p>
<pre><code class="language-json">{
  &quot;arrowParens&quot;: &quot;always&quot;,
  &quot;bracketSpacing&quot;: true,
  &quot;tabWidth&quot;: 80
}
</code></pre>
<p>It's possible to add <a href="https://prettier.io/docs/en/configuration.html#configuration-overrides">overrides</a> tied to specific file formats:</p>
<pre><code class="language-nix">{
    config = {
      arrowParens = &quot;always&quot;;
      bracketSpacing = true;
      tabWidth = 80;
      overrides = [
        {
          files = &quot;*.js&quot;;
          options = {
            semi = true;
          };
        }
      ];
    };
}
</code></pre>
<p>Produces:</p>
<pre><code class="language-json">{
  &quot;arrowParens&quot;: &quot;always&quot;,
  &quot;bracketSpacing&quot;: true,
  &quot;overrides&quot;: [
    {
      &quot;files&quot;: &quot;*.js&quot;,
      &quot;options&quot;: {
        &quot;semi&quot;: true
      }
    }
  ],
  &quot;tabWidth&quot;: 80
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>This chapter covers the details required to contribute to Nixago. Before
submitting a PR, please ensure you review this chapter thoroughly. Nixago has an
opinionated design and expects a specific structure to work correctly.
Understanding this structure ahead of time will make development more accessible
and increase the chance of PRs going through without issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>When contributing to Nixago, it's essential to understand the general design
principles that guide its development. This section provides details on how the
library is structured and introduces the basic concepts required to contribute
effectively.</p>
<h2 id="cue"><a class="header" href="#cue">CUE</a></h2>
<p>The primary tool underlying Nixago is <a href="https://cuelang.org/">CUE</a>. CUE stands for Configure, Unify,
and Execute. It's a general-purpose language for defining, generating, and
validating data. This flake chose CUE for its strengths in configuration
validation and generation. It's also a young project with a rapidly growing
platform.</p>
<p>Learning the CUE language is necessary for contributing plugins. Don't worry,
though. It's much easier to pick up than Nix. Please review the <a href="https://cuetorials.com/introduction/">Cuetorials
website</a> and the <a href="https://cuelang.org/docs/concepts/logic/">Logic of CUE</a> to get an overview of the CUE language.</p>
<p>When creating a plugin, you'll need to write a CUE schema that can validate the
incoming configuration data. The schema ensures that configuration data is
accurate, and it also creates the foundation for transforming that data into the
format needed for the configuration file.</p>
<h2 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h2>
<p>The main interface that Nixago provides is through its <a href="https://github.com/jmgilman/nixago/tree/master/plugins">plugin</a>
infrastructure. A plugin is simply a tiny wrapper that generates a configuration
file for a specific tool. The structure of plugins is consistent in that they
ingest data from the user and produce an instance of the
<a href="contributing/design.html#templates">template module</a>. This module provides a derivation to build the
desired configuration file and a shell hook that will manage a symlink to the
file locally.</p>
<p>Plugins are the primary source of contribution to Nixago. Individuals are
encouraged to contribute plugins for their tools of choice so that the wider
community may benefit from the plugin.</p>
<p><a href="contributing/plugins.html">See here</a> for detailed steps for adding plugins.</p>
<h2 id="templates"><a class="header" href="#templates">Templates</a></h2>
<p>The <a href="https://github.com/jmgilman/nixago/blob/master/modules/template.nix">template module</a> is the basic building block of Nixago. It's responsible
for creating the derivation that ultimately generates the configuration file. It
also manages the shell hook for managing the configuration file.</p>
<p>The internal library provides a <a href="https://github.com/jmgilman/nixago/blob/master/lib/template.nix">single function</a> for creating new instances
of the template module. It accepts the following arguments:</p>
<ul>
<li><strong>data</strong>: The raw data provided by the end-user</li>
<li><strong>files</strong>: The files to pass to <code>cue eval</code> (typically .cue files)</li>
<li><strong>output</strong>: The filename to output</li>
<li><strong>postBuild</strong>: Shellcode to run after the invocation of <code>cue</code> eval`</li>
<li><strong>shellHookExtra</strong>: Additional shellcode to run when the shell hook
regenerates the file</li>
<li><strong>flags</strong>: Additional flags to pass to <code>cue eval</code></li>
</ul>
<p>The function will return the module's <code>config</code> attribute.</p>
<p>The template module provides two primary outputs:</p>
<ul>
<li><strong>configFile</strong>: A derivation that will build the configuration file</li>
<li><strong>shellHook</strong>: A shell hook that will link the configuration file locally and
update it when it changes</li>
</ul>
<h2 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h2>
<p>The foundational function provided by the internal library is the <a href="https://github.com/jmgilman/nixago/blob/master/lib/eval.nix">eval
function</a>. It interacts with the <code>cue</code> CLI tool via a call to
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/trivial-builders.nix#L27">runCommand</a>. This interaction, in turn, creates a derivation that will
produce the output of invoking the <code>cue eval</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins-2"><a class="header" href="#plugins-2">Plugins</a></h1>
<p>Contributing plugins to Nixago is a multi-step process. Fortunately, the design
of Nixago makes these steps relatively straightforward.</p>
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<p>The following is a helpful checklist to go over before submitting a PR:</p>
<ol>
<li>Is the plugin named after the tool it supports?</li>
<li>Does the plugin have a dedicated directory under <a href="https://github.com/jmgilman/nixago/tree/master/plugins">plugins</a>?</li>
<li>Was the plugin added to the main <a href="https://github.com/jmgilman/nixago/blob/master/plugins/default.nix">default.nix</a>?</li>
<li>Does the plugin have tests written for it?</li>
<li>Have the tests been added to the <a href="https://github.com/jmgilman/nixago/blob/master/flake.nix">flake.nix</a> <code>checks</code> output?</li>
<li>Does the plugin have a dedicated page in the documentation?</li>
</ol>
<p>If you answered yes to all of the above questions, you are ready to submit a PR!</p>
<h2 id="creating-a-plugin"><a class="header" href="#creating-a-plugin">Creating a Plugin</a></h2>
<p>Creating a plugin encompasses three primary tasks:</p>
<ol>
<li>Create a CUE file</li>
<li>Create the Nix functions</li>
<li>Write tests and documentation</li>
</ol>
<p>You should isolate each plugin to a dedicated directory under <a href="https://github.com/jmgilman/nixago/tree/master/plugins">plugins</a>. The
first step is to create a new directory with the plugin's name. The name should
ideally indicate the tool that it supports (i.e., the plugin for the Prettier
formatter is called <code>prettier</code>).</p>
<p>The remainder of this section will walk through creating a plugin for the
<a href="https://pre-commit.com/">pre-commit</a> CLI tool. The plugin will generate a <code>.pre-commit-config.yaml</code>
file to configure the pre-commit tool.</p>
<h3 id="creating-the-cue-file"><a class="header" href="#creating-the-cue-file">Creating the CUE file</a></h3>
<p>Review the <a href="contributing/design.html#cue">CUE section</a> of the design page for more information
about CUE. Each plugin typically utilizes a single CUE file, although more
advanced cases may require multiple files. The file should be called
<code>template.cue</code>.</p>
<p>When creating the CUE file, keep the following in mind:</p>
<ul>
<li>
<p>The schema defined in the file should be sufficient to prevent most
configuration mistakes.</p>
</li>
<li>
<p>If the supported tool has rich documentation around valid values for each
configuration field, use constraints to improve the accuracy of the schema.</p>
</li>
<li>
<p>Don't be overly strict with the schema definition. The goal is to be helpful
and not generate many false negatives.</p>
</li>
</ul>
<p>Here is the <code>template.nix</code> file for our pre-commit plugin:</p>
<pre><code class="language-cue">#Config: {
    default_install_hook_types?: [...string]
    default_language_version?: [string]: string
    default_stages?: [...string]
    files?: string
    exclude?: string
    fail_fast?: bool
    minimum_pre_commit_version?: string
    repos: [...#Repo]
}

#Hook: {
    additional_dependencies?: [...string]
    alias?: string
    always_run?: bool
    args?: [...string]
    entry?: string
    exclude?: string
    exclude_types?: [...string]
    files?: string
    id: string
    language?: string
    language_version?: string
    log_file?: string
    name?: string
    stages?: [...string]
    types?: [...string]
    types_or?: [...string]
    verbose?: bool
}

#Repo: {
    repo: string
    rev?: string
    if repo != &quot;local&quot; {
        rev: string
    }
    hooks: [...#Hook]
}

{
    #Config
}
</code></pre>
<p>This file defines three <a href="https://cuetorials.com/overview/types-and-values/#definitions">definitions</a>, notated by the <code>#</code> symbol. A
definition is synonymous with a schema or contract. It describes the shape of
valid data through various constraints. Let's break one down:</p>
<pre><code class="language-cue">#Repo: {
    repo: string
    rev?: string
    if repo != &quot;local&quot; {
        rev: string
    }
    hooks: [...#Hook]
}
</code></pre>
<p>The <code>pre-commit-config.yaml</code> file has a <code>repos</code> field which is a list of
repositories that pre-commit should build from. The <code>#Repo</code> definition provides
the schema for these entries. Each entry must have a <code>repo</code> field which is a
string value. The <code>rev</code> field is interesting: it's only optional if the <code>repo</code>
field is set to &quot;local&quot;. The above sets the <code>rev</code> field to optional using the
<code>?</code> symbol and then conditonally sets it to required based on the value of
<code>repo</code>. Finally, each entry has a list of hooks, denoted by the <code>[...#Hooks]</code>
syntax.</p>
<pre><code class="language-cue">{
    #Config
}
</code></pre>
<p>This final bit is where we define the elements of the CUE file. This is what
will appear when we evaluate the CUE file. In the above case, we're saying the
input data should be a <a href="https://cuetorials.com/overview/types-and-values/#structs">struct</a> that conforms to the schema defined by
<code>#Config</code>.</p>
<p>We're doing no additional transformations to the incoming data in this case. We
expect the input data to be in the format defined in the
<code>.pre-commit-config.yaml</code> file. Since YAML is a superset of JSON, we can easily
ask CUE to evaluate the input and produce a YAML output.</p>
<h3 id="creating-the-nix-functions"><a class="header" href="#creating-the-nix-functions">Creating the Nix Functions</a></h3>
<p>With the CUE file created, the next step is to make our primary Nix function. We
will create a single function for generating our configuration file. First,
let's examine the basic structure of a plugin function:</p>
<pre><code class="language-nix">{ pkgs, lib }:
{ configData, output ? &quot;file.json&quot;, mode ? &quot;link&quot; }:
with pkgs.lib;
let
  # Define input files
  files = [ ./template.cue ];

  # Add ddditional logic here

  # Generate the module
  result = lib.mkTemplate {
    inherit configData files mode output;
  };
in
{
  inherit (result) configFile shellHook;
}
</code></pre>
<p>It's assumed that all plugin functions are defined in this way. You must use
this as a template to start with and then add logic as needed. Let's break down
this structure to better understand each component.</p>
<p>The function takes two arguments, both of them being attribute sets. The first
attribute set is invisible to the end-user and is instead passed by the internal
flake so that the plugin has access to a copy of <code>nixpkgs</code> and the internal
flake <code>lib</code> output. The second attribute set is standardized and should contain
the attributes shown. They are explained below:</p>
<ul>
<li><strong>configData</strong>: This is the raw configuration data provided by the end user</li>
<li><strong>output</strong>: This is the file path where the generated file will be managed</li>
<li><strong>mode</strong>: This determines how the file is managed: the default is <code>link</code> that
instructs the file to be symlinked. However, it can also be changed to <code>copy</code>
instead to maintain a local copy of the generated configuration file.</li>
</ul>
<p>You should change the default values of the last two attributes as needed. It
makes more sense to maintain a copy of a file rather than a symlink in some
cases. The output path is relative to the current working directory of the user.
Most configuration files reside at the root; however, it's possible to nest the
configuration deeper (i.e., <code>configs/file.json</code>).</p>
<p>You are not restricted from adding additional attributes to the second argument.
The only requirement is you keep the three listed above. It's recommended you
document the additional attributes added, including what they do, so that the
end user understands what options are available for controlling the plugin.</p>
<p>The remainder of the function is fairly self-explanatory. We declare the input
files to be passed to <code>cue eval</code> in the <code>files</code> variable. We conclude with a
call to <code>lib.mkTemplate</code>, which contains all of the necessary logic for
generating the output the end user is expecting. This function has additional
arguments that can be passed to customize the result; namely, <code>shellHookExtra</code>
for adding additional logic to the generated shell hook and <code>postBuild</code> for
adding additional logic after <code>cue eval</code> is run. You can also pass other flags
to <code>cue eval</code> via the <code>flags</code> argument. For more details about this function,
<a href="contributing/design.html#templates">see here</a>.</p>
<p>The returned output is standardized and should not be changed. Here is the final
result of our function for the pre-commit plugin:</p>
<pre><code class="language-nix">{ pkgs, lib }:
{ configData, output ? &quot;.pre-commit-config.yaml&quot;, mode ? &quot;link&quot; }:
with pkgs.lib;
let
  files = [ ./template.cue ];
  pre-commit = pkgs.pre-commit;

  # Add an extra hook for reinstalling required stages whenever the file changes
  stages = unique (flatten
    (builtins.map
      (repo: builtins.map
        (hook: optionals (hook ? stages) hook.stages)
        repo.hooks)
      configData.repos) ++ [ &quot;pre-commit&quot; ]);
  stagesStr = builtins.concatStringsSep &quot; &quot; stages;
  shellHookExtra =
    (import ./common.nix { inherit pre-commit stagesStr; }).shellHookExtra;

  # Generate the module
  result = lib.mkTemplate {
    inherit configData files mode output shellHookExtra;
  };
in
{
  inherit (result) configFile shellHook;
}
</code></pre>
<p>We must take two additional steps for our plugin to be picked up by the flake.
The first is creating a <code>default.nix</code> in our plugin directory that exports our
function:</p>
<pre><code class="language-nix">{ pkgs, lib }:
rec {
  default = mkConfig;

  /* Creates a .pre-commit-config.yaml file for configuring pre-commit.
  */
  mkConfig = import ./mkConfig.nix { inherit pkgs lib; };
}
</code></pre>
<p>This will allow the <code>mkConfig</code> function to be accessible under
<code>nixago.plugins.{myPlugin}.mkConfig</code>. Setting the <code>default</code> attribute is
recommended; otherwise, the plugin may not play well with the <code>mkAll</code> function.
You should set it to the most widely used function.</p>
<p>Finally, we must create an entry in the main <code>default.nix</code>:</p>
<pre><code class="language-nix">{ pkgs, lib }:
{
  # ...

  /* https://github.com/pre-commit/pre-commit
  */
  pre-commit = import ./pre-commit { inherit pkgs lib; };

  # ....
}
</code></pre>
<p>This function registers the plugin to make it accessible from <code>nixago.plugins</code>.</p>
<h3 id="writing-tests-and-documentation"><a class="header" href="#writing-tests-and-documentation">Writing Tests and Documentation</a></h3>
<p>The final step is to write tests and documentation for the plugin. Tests live in
the <a href="https://github.com/jmgilman/nixago/tree/master/tests">tests</a> directory in a dedicated directory named after the plugin. Tests
are relatively trivial to write.</p>
<p>The first step is to create a <code>default.nix</code> which runs the test:</p>
<pre><code class="language-nix">{ runTest }:
runTest &quot;pre-commit.mkConfig&quot; ./expected.yml {
  repos = [
    {
      repo = &quot;https://github.com/my/repo&quot;;
      rev = &quot;1.0&quot;;
      hooks = [
        {
          id = &quot;my-hook&quot;;
        }
      ];
    }
  ];
}
{ }

</code></pre>
<p>The <code>runTest</code> helper function provided performs most of the underlying work
required to test the plugin. It takes four arguments: the function to call for
the test, the location of the expected test output, the data to pass to the
specified function, and any additional arguments to pass to the plugin function.</p>
<p>The second step is to create the expected output. In this case, the above
invocation should produce the following result:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - id: my-hook
    repo: https://github.com/my/repo
    rev: &quot;1.0&quot;
</code></pre>
<p>The expected result is compared to the generated output, and the test will fail
if there is a difference.</p>
<p>The final step is to add the test to the <code>checks</code> output in the <code>default.nix</code>
file located at the root of the tests directory:</p>
<pre><code class="language-nix">{
  # ...
  pre-commit = pkgs.callPackage ./pre-commit { inherit runTest; };
  # ...
}
</code></pre>
<p>Finally, before submitting a PR, add documentation under the <a href="https://github.com/jmgilman/nixago/tree/master/docs/plugins">plugins</a>
section of the documentation. Ensure you cover general usage information about
the plugin, including an example invocation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
