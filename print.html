<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Nixago</title>
        <meta name="robots" content="noindex" />
        <!-- Custom HTML head -->
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">
        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">
        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="quick_start.html"><strong aria-hidden="true">1.1.</strong> Quick Start</a></li></ol></li><li class="chapter-item expanded "><a href="plugins/index.html"><strong aria-hidden="true">2.</strong> Plugins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="plugins/just.html"><strong aria-hidden="true">2.1.</strong> Just</a></li><li class="chapter-item expanded "><a href="plugins/lefthook.html"><strong aria-hidden="true">2.2.</strong> Lefthook</a></li><li class="chapter-item expanded "><a href="plugins/pre-commit.html"><strong aria-hidden="true">2.3.</strong> Pre-commit</a></li><li class="chapter-item expanded "><a href="plugins/prettier.html"><strong aria-hidden="true">2.4.</strong> Prettier</a></li></ol></li><li class="chapter-item expanded "><a href="contributing/index.html"><strong aria-hidden="true">3.</strong> Contributing</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="contributing/design.html"><strong aria-hidden="true">3.1.</strong> Design</a></li><li class="chapter-item expanded "><a href="contributing/plugins.html"><strong aria-hidden="true">3.2.</strong> Plugins</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Nixago</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Nixago is a <a href="https://nixos.wiki/wiki/Flakes">flake</a> library that provides functions for generating
configuration files using <a href="https://nixos.org/">Nix</a> and <a href="https://cuelang.org/">Cue</a>. It's primary use is for
generating configuration files for development tools when using a <a href="https://nixos.org/manual/nix/stable/command-ref/nix-shell.html">nix shell</a>
for setting up the development environment. You define the configuration data in
your Nix file and then call out to Nixago to generate it.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Add the flake as an input:</p>
<pre><code class="language-nix">{
  inputs = {
    # ...
    nixago.url = &quot;github:jmgilman/nixago&quot;;
    # ...
  };
}
</code></pre>
<p>Choose a plugin to use. The below example uses the plugin for <a href="https://pre-commit.com/">pre-commit</a>:</p>
<pre><code class="language-nix">{
# ...
    preCommitConfig = {
        nixpkgs-fmt = {
            entry = &quot;${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt&quot;;
            language = &quot;system&quot;;
            files = &quot;\\.nix&quot;;
        };
    };

    preCommit = nixago.plugins.pre-commit.mkLocalConfig preCommitConfig;
# ...
}
</code></pre>
<p>The easiest way to integrate the generated configuration into your development
environment is to use the provided shell hook:</p>
<pre><code class="language-nix">{
# ...
    devShell = pkgs.mkShell {
        shellHook = nixago.lib.mkShellHook [ preCommit ];
    };
# ...
}
</code></pre>
<p>The hook will automatically link the file from the Nix store to the current
working directory. The above example will produce a <code>.pre-commit-config.yaml</code>
file with the following contents:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - entry: /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt
        files: \.nix
        id: nixpkgs-fmt
        language: system
        name: nixpkgs-fmt
    repo: local
</code></pre>
<h2 id="making-multiple-configurations"><a class="header" href="#making-multiple-configurations">Making Multiple Configurations</a></h2>
<p>A utility function is provided for generating multiple configurations. The
following is an excerpt from the <code>flake.nix</code> that manages this project:</p>
<pre><code class="language-nix">{
# Define development tool configuration
    configurations = {
        # Just configuration
        &quot;just&quot; = {
            tasks = {
                check = [
                    &quot;@${tools.nixpkgs-fmt.exe} --check flake.nix $(git ls-files '**/*.nix')&quot;
                    &quot;@${tools.prettier.exe} --check .&quot;
                    &quot;@${tools.typos.exe}&quot;
                    &quot;@nix flake check&quot;
                ];
                check-docs = [
                    &quot;@${tools.typos.exe}&quot;
                ];
                make-docs = [
                    &quot;@cd docs &amp;&amp; mdbook build&quot;
                ];
                fmt = [
                    &quot;@${tools.nixpkgs-fmt.exe} flake.nix $(git ls-files '**/*.nix')&quot;
                    &quot;@${tools.prettier.exe} -w .&quot;
                ];
            };
        };
        # Lefthook configuration
        &quot;lefthook&quot; = {
        pre-commit = {
            commands = {
                nixpkgs-fmt = {
                    run = &quot;${tools.nixpkgs-fmt.exe} --check {staged_files}&quot;;
                    glob = &quot;*.nix&quot;;
                };
                prettier = {
                    run = &quot;${tools.prettier.exe} --check {staged_files}&quot;;
                    glob = &quot;*.{yaml,yml,md}&quot;;
                };
                typos = {
                    run = &quot;${tools.typos.exe} {staged_files}&quot;;
                };
            };
        };
        };
        # Prettier
        &quot;prettier.mkIgnoreConfig&quot; = [
            &quot;.direnv&quot;
            &quot;tests&quot;
            &quot;lefthook.yml&quot;
        ];
    };

    # ...

    # Local development shell
    devShells = {
        default = pkgs.mkShell {
            shellHook = (lib.mkAll configurations).shellHook;
            packages = tools.all;
        };
    };
}
</code></pre>
<p>The input to <code>mkAll</code> expects an attribute set where the name is one of the
following:</p>
<ol>
<li>A path to the function to be called, relative to the <code>plugins</code> set (i.e. <code>prettier.mkIgnoreConfig</code>)</li>
<li>The name of a plugin</li>
</ol>
<p>In the second case, the <code>default</code> function will be called from the plugin. See
the individual plugins for which function this is. The second parameter is the
configuration to be passed to the function. The result of the function is an
attribute set which has a unified <code>shellHook</code> attribute that contains all of the
logic for managing the configurations. This makes it seamless to add additional
configurations to your existing projects.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins"><a class="header" href="#plugins">Plugins</a></h1>
<p>Nixago provides most functionality through plugins. Each plugin targets a
specific configuration by providing a clean interface for end-users. While most
plugins follow a common schema, the varying requirements of configurations can
require minor differences.</p>
<p>Plugins can be accessed via <code>nixago.plugins.${pluginName}</code>. For what functions
a plugin provides, see the relevant documentation page or check the source code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="just"><a class="header" href="#just">Just</a></h1>
<p>This plugin generates the <code>.just</code> file used by the <a href="https://github.com/casey/just">Just</a> task runner. It
provides a single function which allows you to declare a header section and
then subsequent tasks/steps.</p>
<h2 id="using-mkconfig"><a class="header" href="#using-mkconfig">Using mkConfig</a></h2>
<pre><code class="language-nix">{
  just = plugins.just.mkConfig {
    config = {
      head = ''
        var := &quot;value&quot;
      '';
      tasks = {
        task1 = [
          ''echo &quot;Doing the thing&quot;''
          &quot;@doThing&quot;
        ];
      };
    };
  };
}
</code></pre>
<p>The configuration has two major sections. The first is the <code>header</code> field which
is a raw string that will be prepended to the top of the file. This is typically
where global settings and variables are defined in the Justfile. The second is
the <code>tasks</code> field which is a map of task names to a list of their respective
steps. Each step in the list should ideally encompass a single action (this is
idiomatic for Justfiles), however, multiline strings will also work.</p>
<p>The above example will produce the following file contents:</p>
<pre><code class="language-just">var := &quot;value&quot;

task1:
    echo &quot;Doing the thing&quot;
    @doThing
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lefthook"><a class="header" href="#lefthook">Lefthook</a></h1>
<p>This plugin generates the <code>lefthook.yml</code> file for configuring <a href="https://github.com/evilmartians/lefthook">Lefthook</a>.
It provides a single function which allows configuring any of the
<a href="https://github.com/evilmartians/lefthook/blob/master/docs/full_guide.md">valid options</a>.</p>
<h2 id="using-mkconfig-1"><a class="header" href="#using-mkconfig-1">Using mkConfig</a></h2>
<pre><code class="language-nix">{
    config = {
        commit-msg = {
            scripts = {
                template_checker = { runner = &quot;bash&quot;; };
            };
        };
        pre-commit = {
            commands = {
                stylelint = {
                    tags = &quot;frontend style&quot;;
                    glob = &quot;*.js&quot;;
                    run = &quot;yarn stylelint {staged_files}&quot;;
                };
                rubocop = {
                    tags = &quot;backend style&quot;;
                    glob = &quot;*.rb&quot;;
                    exclude = &quot;application.rb|routes.rb&quot;;
                    run = &quot;bundle exec rubocop --force-exclusion {all_files}&quot;;
                };
            };
            scripts = {
                &quot;good_job.js&quot; = { runner = &quot;node&quot;; };
            };
        };
    };
}
</code></pre>
<p>Produces the following <code>lefthook.yml</code>:</p>
<pre><code class="language-yaml">commit-msg:
  scripts:
    template_checker:
      runner: bash
pre-commit:
  commands:
    rubocop:
      exclude: application.rb|routes.rb
      glob: &quot;*.rb&quot;
      run: bundle exec rubocop --force-exclusion {all_files}
      tags: backend style
    stylelint:
      glob: &quot;*.js&quot;
      run: yarn stylelint {staged_files}
      tags: frontend style
  scripts:
    good_job.js:
      runner: node
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="pre-commit"><a class="header" href="#pre-commit">Pre-commit</a></h1>
<p>This plugin generates the <code>.pre-commit-config.yaml</code> file used to configure
<a href="https://pre-commit.com/">pre-commit</a>. It provides two functions for generating the configuration.</p>
<h2 id="using-mkconfig-2"><a class="header" href="#using-mkconfig-2">Using mkConfig</a></h2>
<p>The first function follows the <a href="https://pre-commit.com/#adding-pre-commit-plugins-to-your-project">structure described in the docs</a>:</p>
<pre><code class="language-nix">{
  pre-commit = nixago.plugins.pre-commit.mkConfig {
    config = {
      repos = [
        {
          repo = &quot;https://github.com/my/repo&quot;;
          rev = &quot;1.0&quot;;
          hooks = [
            {
              id = &quot;my-hook&quot;;
            }
          ];
        }
      ];
    };
  };
}
</code></pre>
<p>The structure is validated by Cue and the derivation will fail to build if a
mistake is made. The above configuration will create the following file
contents:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - id: my-hook
    repo: https://github.com/my/repo
    rev: &quot;1.0&quot;
</code></pre>
<h2 id="using-mklocalconfig"><a class="header" href="#using-mklocalconfig">Using mkLocalConfig</a></h2>
<p>The second function accepts a simplified configuration format the greatly
reduces the verbosity. When managing pre-commit with Nix, it's often desirable
to create a single &quot;local&quot; repo entry and then add system hooks which call out
to binaries in the Nix store. The benefit of this approach is that Nix manages
the versioning of the binaries and you have greater control over how the hook
operates.</p>
<p>The accepted format is as follows:</p>
<pre><code class="language-nix">{
    nixpkgs-fmt = {
        entry = &quot;${pkgs.nixpkgs-fmt}/bin/nixpkgs-fmt&quot;;
        language = &quot;system&quot;;
        files = &quot;\\.nix&quot;;
    }
}
</code></pre>
<p>The format is a set consisting of hook names as the keys and their configuration
properties as values. The <code>id</code> and <code>name</code> fields of the hook configuration are
automatically set to the hook name (i.e., <code>nixpkgs-fmt</code>). The <code>entry</code> should
point to the binary which will be called by pre-commit. Setting <code>language</code> to
system ensures that the <code>entry</code> is called with the default shell. Finally,
setting <code>files</code> ensures that pre-commit only passes Nix files to this hook. The
above configuration would produce the following <code>pre-commit-config.yaml</code> file:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - entry: /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt
        files: \.nix
        id: nixpkgs-fmt
        language: system
        name: nixpkgs-fmt
    repo: local
</code></pre>
<p>Notice how the <code>repos</code> and <code>repo</code> properties are already set.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="prettier"><a class="header" href="#prettier">Prettier</a></h1>
<p>This plugin generates the <code>.prettierrc.json</code> file for configuring <a href="https://prettier.io/">Prettier</a>.
It provides a single function which allows you to configure any of the
<a href="https://prettier.io/docs/en/options.html">valid API options</a>.</p>
<h2 id="using-mkconfig-3"><a class="header" href="#using-mkconfig-3">Using mkConfig</a></h2>
<p>The schema for the configuration file is <a href="https://prettier.io/docs/en/configuration.html">detailed here</a>. For example:</p>
<pre><code class="language-nix">{
    config = {
      arrowParens = &quot;always&quot;;
      bracketSpacing = true;
      tabWidth = 80;
    };
}
</code></pre>
<p>Produces the following <code>.prettierrc.json</code>:</p>
<pre><code class="language-json">{
  &quot;arrowParens&quot;: &quot;always&quot;,
  &quot;bracketSpacing&quot;: true,
  &quot;tabWidth&quot;: 80
}
</code></pre>
<p><a href="https://prettier.io/docs/en/configuration.html#configuration-overrides">Overrides</a> can be supplied that are tied to specific file formats:</p>
<pre><code class="language-nix">{
    config = {
      arrowParens = &quot;always&quot;;
      bracketSpacing = true;
      tabWidth = 80;
      overrides = [
        {
          files = &quot;*.js&quot;;
          options = {
            semi = true;
          };
        }
      ];
    };
}
</code></pre>
<p>Produces:</p>
<pre><code class="language-json">{
  &quot;arrowParens&quot;: &quot;always&quot;,
  &quot;bracketSpacing&quot;: true,
  &quot;overrides&quot;: [
    {
      &quot;files&quot;: &quot;*.js&quot;,
      &quot;options&quot;: {
        &quot;semi&quot;: true
      }
    }
  ],
  &quot;tabWidth&quot;: 80
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="contributing"><a class="header" href="#contributing">Contributing</a></h1>
<p>This chapter covers the details required to contribute to Nixago. Before
submitting a PR, please ensure you review this chapter thoroughly. Nixago has
an opionated design and expects a certain structure in order to work correctly.
Understanding this structure ahead of time will make development easier and
increase the chance of PRs going through without issues.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="design"><a class="header" href="#design">Design</a></h1>
<p>When contributing to Nixago, it's important to understand the general design
principles that guide its development. This section provides details on how the
library is structured and introduces the basic concepts required to effectively
contribute to it.</p>
<h2 id="cue"><a class="header" href="#cue">CUE</a></h2>
<p>The primary tool underlying Nixago is <a href="https://cuelang.org/">CUE</a>. CUE stands for Configure, Unify,
and Execute. It's a general-purpose language for defining, generating, and
validating data. CUE was chosen for its strengths in the areas of configuration
validation and generation. It's also a young project with a rapidly growing
platform.</p>
<p>Learning the CUE language is necessary for contributing plugins. Don't worry,
though, it's much easier to pickup than Nix. It's recommended to review the
<a href="https://cuetorials.com/introduction/">Cuetorials website</a> to get an overview of the CUE language. The
<a href="https://cuelang.org/docs/concepts/logic/">Logic of CUE</a> is also recommended.</p>
<p>When creating a plugin, you'll need to write a CUE schema that can validate the
incoming configuration data. The schema not only ensures that configuration data
is accurate, but it also creates the foundation for transforming that data into
the format needed for the configuration file.</p>
<h2 id="plugins-1"><a class="header" href="#plugins-1">Plugins</a></h2>
<p>The main interface that Nixago provides is through its <a href="https://github.com/jmgilman/nixago/tree/master/plugins">plugin</a>
infrastructure. A plugin is simply a small wrapper which generates a
configuration file for a specific tool. The structure of plugins is consistent
in that they ingest data from the user and produce an instance of the
<a href="contributing/design.html#templates">template module</a>. This module provides a derivation which will
build the desired configuration file as well as a shell hook which will manage
linking the file locally.</p>
<p>Plugins are the main source of contribution to Nixago. Individuals are
encouraged to contribute plugins for their tools of choice so that the wider
community may benefit from the plugin.</p>
<p><a href="contributing/plugins.html">See here</a> for detailed steps for adding plugins.</p>
<h2 id="templates"><a class="header" href="#templates">Templates</a></h2>
<p>The <a href="https://github.com/jmgilman/nixago/blob/master/modules/template.nix">template module</a> is the basic building block of Nixago. It's responsible
for creating the derivation that ultimately generates the configuration file. It
also creates the shell hook which manages the configuration file.</p>
<p>The internal library provides a <a href="https://github.com/jmgilman/nixago/blob/master/lib/template.nix">single function</a> for creating new instances
of the template module. It accepts the following arguments:</p>
<ul>
<li><strong>data</strong>: The raw data provided from the end-user</li>
<li><strong>files</strong>: The files to pass to <code>cue eval</code> (typically .cue files)</li>
<li><strong>output</strong>: The filename to output</li>
<li><strong>postBuild</strong>: Shell code to run after <code>cue eval</code> is invoked</li>
<li><strong>shellHookExtra</strong>: Additional shell code to run when the file is regenered by the shell hook</li>
<li><strong>flags</strong>: Additional flags to pass to <code>cue eval</code></li>
</ul>
<p>The function will return the module's <code>config</code> attribute.</p>
<p>The template module provides two primary outputs:</p>
<ul>
<li><strong>configFile</strong>: A derivation that will build the configuration file</li>
<li><strong>shellHook</strong>: A shell hook which will link the configuration file locally and update it when it changes</li>
</ul>
<h2 id="evaluation"><a class="header" href="#evaluation">Evaluation</a></h2>
<p>The foundational function provided by the internal library is the
<a href="https://github.com/jmgilman/nixago/blob/master/lib/eval.nix">eval function</a>. It interacts with the <code>cue</code> CLI tool via a call to
<a href="https://github.com/NixOS/nixpkgs/blob/master/pkgs/build-support/trivial-builders.nix#L27">runCommand</a>. This, in turn, creates a derivation which will produce the
output of invoking the <code>cue eval</code> command.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="plugins-2"><a class="header" href="#plugins-2">Plugins</a></h1>
<p>Contributing plugins to Nixago is a multi-step process. Fortunately, the design
of Nixago makes these steps relatively straightforward.</p>
<h2 id="checklist"><a class="header" href="#checklist">Checklist</a></h2>
<p>The following is a useful checklist to go over before submitting a PR:</p>
<ol>
<li>Is the plugin named after the tool it supports?</li>
<li>Does the plugin have a dedicated directory under <a href="https://github.com/jmgilman/nixago/tree/master/plugins">plugins</a>?</li>
<li>Was the plugin added to the main <a href="https://github.com/jmgilman/nixago/blob/master/plugins/default.nix">default.nix</a>?</li>
<li>Does the plugin have tests written for it?</li>
<li>Have the tests been added to the <a href="https://github.com/jmgilman/nixago/blob/master/flake.nix">flake.nix</a> <code>checks</code> output?</li>
<li>Does the plugin have a dedicated page in the documentation?</li>
</ol>
<p>If you answered yes to all of the above questions you are ready to submit a PR!</p>
<h2 id="creating-a-plugin"><a class="header" href="#creating-a-plugin">Creating a Plugin</a></h2>
<p>Creating a plugin encompasses three primary tasks:</p>
<ol>
<li>Create a CUE file</li>
<li>Create the Nix functions</li>
<li>Write tests and documentation</li>
</ol>
<p>Each plugin should be isolated to a dedicated directory under <a href="https://github.com/jmgilman/nixago/tree/master/plugins">plugins</a>. The
first step is to create a new directory with the name of the plugin. The name
should ideally indicate the tool that it supports (i.e. the plugin for the
Prettier formatter is simply called <code>prettier</code>).</p>
<p>The remainder of this section will walk through creating a plugin for the
<a href="https://pre-commit.com/">pre-commit</a> CLI tool. The plugin will generate a <code>.pre-commit-config.yaml</code>
file which is used to configure the pre-commit tool.</p>
<h3 id="creating-the-cue-file"><a class="header" href="#creating-the-cue-file">Creating the CUE file</a></h3>
<p>Review the <a href="contributing/design.html#cue">CUE section</a> of the design page for more information
about CUE. Each plugin typically utilizes a single CUE file, although more
advanced cases may require multiple files. The file should be called
<code>template.cue</code>.</p>
<p>When creating the CUE file, keep the following in mind:</p>
<ul>
<li>
<p>The schema defined in the file should be sufficient enough to prevent most
configuration mistakes.</p>
</li>
<li>
<p>If the tool being supported has rich documentation around valid values for
each configuration field, use constraints to improve the accuracy of the schema.</p>
</li>
<li>
<p>Don't be overly strict with the schema definition. The goal is to be helpful
and not generate a large number of false negatives.</p>
</li>
</ul>
<p>Here is the <code>template.nix</code> file for our pre-commit plugin:</p>
<pre><code class="language-cue">#Config: {
    default_install_hook_types?: [...string]
    default_language_version?: [string]: string
    default_stages?: [...string]
    files?: string
    exclude?: string
    fail_fast?: bool
    minimum_pre_commit_version?: string
    repos: [...#Repo]
}

#Hook: {
    additional_dependencies?: [...string]
    alias?: string
    always_run?: bool
    args?: [...string]
    entry?: string
    exclude?: string
    exclude_types?: [...string]
    files?: string
    id: string
    language?: string
    language_version?: string
    log_file?: string
    name?: string
    stages?: [...string]
    types?: [...string]
    types_or?: [...string]
    verbose?: bool
}

#Repo: {
    repo: string
    rev?: string
    if repo != &quot;local&quot; {
        rev: string
    }
    hooks: [...#Hook]
}

{
    #Config
}
</code></pre>
<p>This file defines three <a href="https://cuetorials.com/overview/types-and-values/#definitions">definitions</a>, notated by the <code>#</code> symbol. A
definition can be thought of as a schema or contract. It defines the shape of
valid data through various constraints. Let's break one down:</p>
<pre><code class="language-cue">#Repo: {
    repo: string
    rev?: string
    if repo != &quot;local&quot; {
        rev: string
    }
    hooks: [...#Hook]
}
</code></pre>
<p>The <code>pre-commit-config.yaml</code> file has a <code>repos</code> field which is a list of
repositories that pre-commit should build from. The <code>#Repo</code> definition provides
the schema for these entries. Each entry must have a <code>repo</code> field which is a
string value. The <code>rev</code> field is an interesting one: it's only optional if the
<code>repo</code> field is set to &quot;local&quot;. The above first sets the <code>rev</code> field to optional
using the <code>?</code> symbol and then conditonally sets it to required based on the
value of <code>repo</code>. Finally, each entry has a list of hooks, denoted by the
<code>[...#Hooks]</code> syntax.</p>
<pre><code class="language-cue">{
    #Config
}
</code></pre>
<p>This final bit is where we define the actual elements of the CUE file. This is
what will appear when we evaluate the CUE file. In the above case, we're saying
the input data should be a <a href="https://cuetorials.com/overview/types-and-values/#structs">struct</a> which conforms to the schema defined by
<code>#Config</code>.</p>
<p>In this case, we're doing no additional transformations to the incoming data.
This is because we're expecting the input data to already be in the format
expected in the <code>.pre-commit-config.yaml</code> file. Since YAML is a superset of
JSON, we can easily ask CUE to evaluate the input and produce a YAML output.</p>
<h3 id="creating-the-nix-functions"><a class="header" href="#creating-the-nix-functions">Creating the Nix Functions</a></h3>
<p>With the CUE file created, the next step is to create our main Nix function. In
this case, we're going to create a single function for generating our
configuration file.</p>
<pre><code class="language-nix">{ pkgs, lib }:
data:
with pkgs.lib;
let
  files = [ ./template.cue ];
  output = &quot;.pre-commit-config.yaml&quot;;
  pre-commit = pkgs.pre-commit;

  # Add an extra hook for reinstalling required stages whenever the file changes
  stages = unique (flatten (builtins.map (repo: builtins.map (hook: optionals (hook ? stages) hook.stages) repo.hooks) data.repos) ++ [ &quot;pre-commit&quot; ]);
  stagesStr = builtins.concatStringsSep &quot; &quot; stages;
  shellHookExtra = (import ./common.nix { inherit pre-commit stagesStr; }).shellHookExtra;

  # Generate the module
  result = lib.mkTemplate {
    inherit data files output shellHookExtra;
  };
in
{
  inherit (result) configFile shellHook;
}
</code></pre>
<p>All functions maintain the same basic structure. At the top we accept an
attribute set as the first argument which pulls in local copies of <code>nixpkgs</code>
and the internal <code>lib</code> provided by the flake. The second argument should always
be named <code>data</code> and will contain the data passed in by the end-user.</p>
<p>The top of the function should declare the <code>files</code> and <code>output</code> variables. The
<code>files</code> variable should point to the CUE file we previously created. The
<code>output</code> variable should contain the name of the configuration file the plugin
is generating. Note that the extension of the configuration file is important.
CUE uses the file extension to determine what format to output when our CUE file
is evaluated. <a href="https://cuelang.org/docs/integrations/">See here</a> for supported formats.</p>
<p>The remainder of the function is specific to each plugin. In the case above,
we gather all of the pre-commit <code>stages</code> settings to determine what stages of
the pre-commit process should be installed when the configuration is generated.
We then create <code>shellHookExtra</code> which contains the necessary logic for
installing the stages.</p>
<p>At the very end, the internal <code>mkTemplate</code> function is called. For more details
about this function, <a href="contributing/design.html#templates">see here</a>.</p>
<p>In order for our plugin to be picked up by the main flake, we must take two
additional steps. The first is creating a <code>default.nix</code> in our plugin directory
that exports our function:</p>
<pre><code class="language-nix">{ pkgs, lib }:
rec {
  default = mkConfig;

  /* Creates a .pre-commit-config.yaml file for configuring pre-commit.
  */
  mkConfig = import ./mkConfig.nix { inherit pkgs lib; };
}
</code></pre>
<p>This will allow the <code>mkConfig</code> function to be accessible under
<code>nixago.plugins.{myPlugin}.mkConfig</code>. Setting the <code>default</code> attribute is
recommended, otherwise the plugin may not play well with the <code>mkAll</code> function.
It should be set to most widely used function.</p>
<p>Finally, we must create an entry in the main <code>default.nix</code>:</p>
<pre><code class="language-nix">{ pkgs, lib }:
{
  # ...

  /* https://github.com/pre-commit/pre-commit
  */
  pre-commit = import ./pre-commit { inherit pkgs lib; };

  # ....
}
</code></pre>
<p>This registers the plugin to make it accessible from <code>nixago.plugins</code>.</p>
<h3 id="writing-tests-and-documentation"><a class="header" href="#writing-tests-and-documentation">Writing Tests and Documentation</a></h3>
<p>The final step is to write tests and documentation for the plugin. Tests are
added in the <a href="https://github.com/jmgilman/nixago/tree/master/tests">tests</a> directory in a dedicated directory named after the
plugin. Tests are fairly trivial to write.</p>
<p>The first step is to create a <code>default.nix</code> which runs the test:</p>
<pre><code class="language-nix">{ pkgs, plugins }:
let
  output = plugins.pre-commit.mkConfig {
    repos = [
      {
        repo = &quot;https://github.com/my/repo&quot;;
        rev = &quot;1.0&quot;;
        hooks = [
          {
            id = &quot;my-hook&quot;;
          }
        ];
      }
    ];
  };

  result = pkgs.runCommand &quot;test.pre-commit&quot;
    { }
    ''
      cmp &quot;${./expected.yml}&quot; &quot;${output.configFile}&quot;
      touch $out
    '';
in
result
</code></pre>
<p>The test is made up of two parts: a sample configuration is generated and then
it is compared to a known expected output. The test will be provided an instance
of <code>plugins</code> in order to access functions for testing. The usage of <code>runCommand</code>
in the second part will necessarily build the derivation which is returned from
the function.</p>
<p>The second step is to create the expected output. In this case, the above
invocation should create the following output:</p>
<pre><code class="language-yaml">repos:
  - hooks:
      - id: my-hook
    repo: https://github.com/my/repo
    rev: &quot;1.0&quot;
</code></pre>
<p>The generateed output will be compared to this and the test will fail if a
difference is found.</p>
<p>The final step is to add the tests to the <code>checks</code> output in the main
<code>flake.nix</code> file:</p>
<pre><code class="language-nix">{
    checks = {
        #...
        pre-commit = pkgs.callPackage ./tests/pre-commit { inherit pkgs plugins; };
        #...
    };
}
</code></pre>
<p>Finally, before submitting a PR, documentation should be added under the
<a href="https://github.com/jmgilman/nixago/tree/master/docs/plugins">plugins</a> section of the documentation. This should cover general usage
information about the plugin including an example invocation.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
            </nav>

        </div>

        <script type="text/javascript">
            window.playground_copyable = true;
        </script>
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
    </body>
</html>
