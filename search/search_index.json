{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Nixago Nixago is a flake library that provides functions for generating configuration files using Nix and Cue . It's primary use is for generating configuration files for development tools when using a nix shell for setting up the development environment. You define the configuration data in your Nix file and then call out to Nixago to generate it.","title":"Home"},{"location":"#nixago","text":"Nixago is a flake library that provides functions for generating configuration files using Nix and Cue . It's primary use is for generating configuration files for development tools when using a nix shell for setting up the development environment. You define the configuration data in your Nix file and then call out to Nixago to generate it.","title":"Nixago"},{"location":"quick_start/","text":"Quick Start Add the flake as an input: Nix 1 2 3 4 5 6 7 { inputs = { # ... nixago . url = \"github:jmgilman/nixago\" ; # ... }; } Choose a plugin to use. The below example uses the plugin for pre-commit : Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 { # ... preCommitConfig = { nixpkgs-fmt = { entry = \" ${ pkgs . nixpkgs-fmt } /bin/nixpkgs-fmt\" ; language = \"system\" ; files = \" \\\\ .nix\" ; }; }; preCommit = nixago . plugins . pre-commit . mkLocalConfig preCommitConfig ; # ... } The easiest way to integrate the generated configuration into your development environment is to use the provided shell hook: Nix 1 2 3 4 5 6 7 { # ... devShell = pkgs . mkShell { shellHook = nixago . lib . mkShellHook [ preCommit ]; }; # ... } The hook will automatically link the file from the Nix store to the current working directory. The above example will produce a .pre-commit-config.yaml file with the following contents: YAML 1 2 3 4 5 6 7 8 repos : - hooks : - entry : /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt files : \\.nix id : nixpkgs-fmt language : system name : nixpkgs-fmt repo : local","title":"Quick Start"},{"location":"quick_start/#quick-start","text":"Add the flake as an input: Nix 1 2 3 4 5 6 7 { inputs = { # ... nixago . url = \"github:jmgilman/nixago\" ; # ... }; } Choose a plugin to use. The below example uses the plugin for pre-commit : Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 { # ... preCommitConfig = { nixpkgs-fmt = { entry = \" ${ pkgs . nixpkgs-fmt } /bin/nixpkgs-fmt\" ; language = \"system\" ; files = \" \\\\ .nix\" ; }; }; preCommit = nixago . plugins . pre-commit . mkLocalConfig preCommitConfig ; # ... } The easiest way to integrate the generated configuration into your development environment is to use the provided shell hook: Nix 1 2 3 4 5 6 7 { # ... devShell = pkgs . mkShell { shellHook = nixago . lib . mkShellHook [ preCommit ]; }; # ... } The hook will automatically link the file from the Nix store to the current working directory. The above example will produce a .pre-commit-config.yaml file with the following contents: YAML 1 2 3 4 5 6 7 8 repos : - hooks : - entry : /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt files : \\.nix id : nixpkgs-fmt language : system name : nixpkgs-fmt repo : local","title":"Quick Start"},{"location":"contributing/design/","text":"Nixago Design When contributing to Nixago, it's important to understand the general design priciples that guide its development. This section provides details on how the library is structured and introduces the basic concepts required to effectively contribute to it. CUE The primary tool underlying Nixago is CUE . CUE stands for Configure, Unify, and Execute. It's a general-purpose language for defining, generating, and validating data. CUE was chosen for its strengths in the areas of configuration validation and generation. It's also a young project with a rapidly growing platform. Learning the CUE language is necessary for contributing plugins. Don't worry, though, it's much easier to pickup than Nix. It's recommended to review the Cuetorials website to get an overview of the CUE language. The Logic of CUE is also recommended. When creating a plugin, you'll need to write a CUE schema that can validate the incoming configuration data. The schema not only ensures that configuration data is accurate, but it also creates the foundation for transforming that data into the format needed for the configuration file. Plugins The main interface that Nixago provides is through its plugin infrastructure. A plugin is simply a small wrapper which generates a configuration file for a specific tool. The structure of plugins is consistent in that they ingest data from the user and produce an instance of the template module . This module provides a derivation which will build the desired configuration file as well as a shell hook which will manage linking the file locally. Plugins are the main source of contribution to Nixago. Individuals are encouraged to contribute plugins for their tools of choice so that the wider community may benefit from the plugin. See here for detailed steps for adding plugins. Templates The template module is the basic building block of Nixago. It's responsible for creating the derivation that ultimately generates the configuration file. It also creates the shell hook which manages the configuration file. The internal library provides a single function for creating new instances of the template module. It accepts the following arguments: data : The raw data provided from the end-user files : The files to pass to cue eval (typically .cue files) output : The filename to output postBuild : Shell code to run after cue eval is invoked shellHookExtra : Additional shell code to run when the file is regenered by the shell hook flags : Additional flags to pass to cue eval The function will return the module's config attribute. The template module provides two primary outputs: configFile : A derivation that will build the configuration file shellHook : A shell hook which will link the configuration file locally and update it when it changes Evaluation The foundational function provided by the internal library is the eval function . It interacts with the cue CLI tool via a call to runCommand . This, in turn, creates a derivation which will produce the output of invoking the cue eval command.","title":"Design"},{"location":"contributing/design/#nixago-design","text":"When contributing to Nixago, it's important to understand the general design priciples that guide its development. This section provides details on how the library is structured and introduces the basic concepts required to effectively contribute to it.","title":"Nixago Design"},{"location":"contributing/design/#cue","text":"The primary tool underlying Nixago is CUE . CUE stands for Configure, Unify, and Execute. It's a general-purpose language for defining, generating, and validating data. CUE was chosen for its strengths in the areas of configuration validation and generation. It's also a young project with a rapidly growing platform. Learning the CUE language is necessary for contributing plugins. Don't worry, though, it's much easier to pickup than Nix. It's recommended to review the Cuetorials website to get an overview of the CUE language. The Logic of CUE is also recommended. When creating a plugin, you'll need to write a CUE schema that can validate the incoming configuration data. The schema not only ensures that configuration data is accurate, but it also creates the foundation for transforming that data into the format needed for the configuration file.","title":"CUE"},{"location":"contributing/design/#plugins","text":"The main interface that Nixago provides is through its plugin infrastructure. A plugin is simply a small wrapper which generates a configuration file for a specific tool. The structure of plugins is consistent in that they ingest data from the user and produce an instance of the template module . This module provides a derivation which will build the desired configuration file as well as a shell hook which will manage linking the file locally. Plugins are the main source of contribution to Nixago. Individuals are encouraged to contribute plugins for their tools of choice so that the wider community may benefit from the plugin. See here for detailed steps for adding plugins.","title":"Plugins"},{"location":"contributing/design/#templates","text":"The template module is the basic building block of Nixago. It's responsible for creating the derivation that ultimately generates the configuration file. It also creates the shell hook which manages the configuration file. The internal library provides a single function for creating new instances of the template module. It accepts the following arguments: data : The raw data provided from the end-user files : The files to pass to cue eval (typically .cue files) output : The filename to output postBuild : Shell code to run after cue eval is invoked shellHookExtra : Additional shell code to run when the file is regenered by the shell hook flags : Additional flags to pass to cue eval The function will return the module's config attribute. The template module provides two primary outputs: configFile : A derivation that will build the configuration file shellHook : A shell hook which will link the configuration file locally and update it when it changes","title":"Templates"},{"location":"contributing/design/#evaluation","text":"The foundational function provided by the internal library is the eval function . It interacts with the cue CLI tool via a call to runCommand . This, in turn, creates a derivation which will produce the output of invoking the cue eval command.","title":"Evaluation"},{"location":"contributing/plugins/","text":"Creating Plugins Contributing plugins to Nixago is a multi-step process. Fortunately, the design of Nixago makes these steps relatively straightforward. Checklist The following is a useful checklist to go over before submitting a PR: Is the plugin named after the tool it supports? Does the plugin have a dedicated directory under plugins ? Was the plugin added to the main default.nix ? Does the plugin have tests written for it? Have the tests been added to the flake.nix checks output? Does the plugin have a dedicated page in the documentation? If you answered yes to all of the above questions you are ready to submit a PR! Creating a Plugin Creating a plugin encompasses three primary tasks: Create a CUE file Create the Nix functions Write tests and documentation Each plugin should be isolated to a dedicated directory under plugins . The first step is to create a new directory with the name of the plugin. The name should ideally indicate the tool that it supports (i.e. the plugin for the Prettier formatter is simply called prettier ). The remainder of this section will walk through creating a plugin for the pre-commit CLI tool. The plugin will generate a .pre-commit-config.yaml file which is used to configure the pre-commit tool. Creating the CUE file Review the CUE section of the design page for more information about CUE. Each plugin typically utilizes a single CUE file, although more advanced cases may require multiple files. The file should be called template.cue . When creating the CUE file, keep the following in mind: The schema defined in the file should be sufficient enough to prevent most configuration mistakes. If the tool being supported has rich documentation around valid values for each configuration field, use constraints to improve the accuracy of the schema. Don't be overly strict with the schema definition. The goal is to be helpful and not generate a large number of false negatives. Here is the template.nix file for our pre-commit plugin: Text Only 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #Config: { default_install_hook_types?: [...string] default_language_version?: [string]: string default_stages?: [...string] files?: string exclude?: string fail_fast?: bool minimum_pre_commit_version?: string repos: [...#Repo] } #Hook: { additional_dependencies?: [...string] alias?: string always_run?: bool args?: [...string] entry?: string exclude?: string exclude_types?: [...string] files?: string id: string language?: string language_version?: string log_file?: string name?: string stages?: [...string] types?: [...string] types_or?: [...string] verbose?: bool } #Repo: { repo: string rev?: string if repo != \"local\" { rev: string } hooks: [...#Hook] } { #Config } This file defines three definitions , notated by the # symbol. A definition can be thought of as a schema or contract. It defines the shape of valid data through various constraints. Let's break one down: Text Only 1 2 3 4 5 6 7 8 #Repo: { repo: string rev?: string if repo != \"local\" { rev: string } hooks: [...#Hook] } The pre-commit-config.yaml file has a repos field which is a list of repositories that pre-commit should build from. The #Repo definition provides the schema for these entries. Each entry must have a repo field which is a string value. The rev field is an interesting one: it's only optional if the repo field is set to \"local\". The above first sets the rev field to optional using the ? symbol and then conditonally sets it to required based on the value of repo . Finally, each entry has a list of hooks, denoted by the [...#Hooks] syntax. Text Only 1 2 3 { #Config } This final bit is where we define the actual elements of the CUE file. This is what will appear when we evaluate the CUE file. In the above case, we're saying the input data should be a struct which conforms to the schema defined by #Config . In this case, we're doing no additional transformations to the incoming data. This is because we're expecting the input data to already be in the format expected in the .pre-commit-config.yaml file. Since YAML is a superset of JSON, we can easily ask CUE to evaluate the input and produce a YAML output. Creating the Nix Functions With the CUE file created, the next step is to create our main Nix function. In this case, we're going to create a single function for generating our configuration file. Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { pkgs , lib }: data : with pkgs . lib ; let files = [ . /template.cue ]; output = \".pre-commit-config.yaml\" ; pre-commit = pkgs . pre-commit ; # Add an extra hook for reinstalling required stages whenever the file changes stages = unique ( flatten ( builtins . map ( repo : builtins . map ( hook : optionals ( hook ? stages ) hook . stages ) repo . hooks ) data . repos ) ++ [ \"pre-commit\" ]); stagesStr = builtins . concatStringsSep \" \" stages ; shellHookExtra = ( import . /common.nix { inherit pre-commit stagesStr ; }) . shellHookExtra ; # Generate the module result = lib . mkTemplate { inherit data files output shellHookExtra ; }; in { inherit ( result ) configFile shellHook ; } All functions maintain the same basic structure. At the top we accept an attribute set as the first argument which pulls in local copies of nixpkgs and the internal lib provided by the flake. The second argument should always be named data and will contain the data passed in by the end-user. The top of the function should declare the files and output variables. The files variable should point to the CUE file we previously created. The output variable should contain the name of the configuration file the plugin is generating. Note that the extension of the configuration file is important. CUE uses the file extension to determine what format to output when our CUE file is evaluated. See here for supported formats. The remainder of the function is specific to each plugin. In the case above, we gather all of the pre-commit stages settings to determine what stages of the pre-commit process should be installed when the configuration is generated. We then create shellHookExtra which contains the necessary logic for installing the stages. At the very end, the internal mkTemplate function is called. For more details about this function, see here . In order for our plugin to be picked up by the main flake, we must take two additional steps. The first is creating a default.nix in our plugin directory that exports our function: Nix 1 2 3 4 5 6 { pkgs , lib }: { /* Creates a .pre-commit-config.yaml file for configuring pre-commit. */ mkConfig = import . /mkConfig.nix { inherit pkgs lib ; }; } This will allow the mkConfig function to be accessible under nixago.plugins.{myPlugin}.mkConfig . Finally, we must create an entry in the main default.nix : Nix 1 2 3 4 5 6 7 8 9 10 { pkgs , lib }: { # ... /* https://github.com/pre-commit/pre-commit */ pre-commit = import . /pre-commit { inherit pkgs lib ; }; # .... } This registers the plugin to make it accessible from nixago.plugins . Writing Tests and Documentation The final step is to write tests and documentation for the plugin. Tests are added in the tests directory in a dedicated directory named after the plugin. Tests are fairly trivial to write. The first step is to create a default.nix which runs the test: Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { pkgs , plugins }: let output = plugins . pre-commit . mkConfig { repos = [ { repo = \"https://github.com/my/repo\" ; rev = \"1.0\" ; hooks = [ { id = \"my-hook\" ; } ]; } ]; }; result = pkgs . runCommand \"test.pre-commit\" { } '' cmp \" ${ . /expected.yml } \" \" ${ output . configFile } \" touch $out '' ; in result The test is made up of two parts: a sample configuration is generated and then it is compared to a known expected output. The test will be provided an instance of plugins in order to access functions for testing. The usage of runCommand in the second part wil necessarily build the derivation which is returned from the function. The second step is to create the expected output. In this case, the above invocation should create the following output: YAML 1 2 3 4 5 repos : - hooks : - id : my-hook repo : https://github.com/my/repo rev : \"1.0\" The generateed output will be compared to this and the test will fail if a difference is found. The final step is to add the tests to the checks output in the main flake.nix file: Nix 1 2 3 4 5 6 7 { checks = { #... pre-commit = pkgs . callPackage . /tests/pre-commit { inherit pkgs plugins ; }; #... }; } Finally, before submitting a PR, documentation should be added under the plugins section of the documentation. This should cover general usage information about the plugin including an example invocation.","title":"Plugins"},{"location":"contributing/plugins/#creating-plugins","text":"Contributing plugins to Nixago is a multi-step process. Fortunately, the design of Nixago makes these steps relatively straightforward.","title":"Creating Plugins"},{"location":"contributing/plugins/#checklist","text":"The following is a useful checklist to go over before submitting a PR: Is the plugin named after the tool it supports? Does the plugin have a dedicated directory under plugins ? Was the plugin added to the main default.nix ? Does the plugin have tests written for it? Have the tests been added to the flake.nix checks output? Does the plugin have a dedicated page in the documentation? If you answered yes to all of the above questions you are ready to submit a PR!","title":"Checklist"},{"location":"contributing/plugins/#creating-a-plugin","text":"Creating a plugin encompasses three primary tasks: Create a CUE file Create the Nix functions Write tests and documentation Each plugin should be isolated to a dedicated directory under plugins . The first step is to create a new directory with the name of the plugin. The name should ideally indicate the tool that it supports (i.e. the plugin for the Prettier formatter is simply called prettier ). The remainder of this section will walk through creating a plugin for the pre-commit CLI tool. The plugin will generate a .pre-commit-config.yaml file which is used to configure the pre-commit tool.","title":"Creating a Plugin"},{"location":"contributing/plugins/#creating-the-cue-file","text":"Review the CUE section of the design page for more information about CUE. Each plugin typically utilizes a single CUE file, although more advanced cases may require multiple files. The file should be called template.cue . When creating the CUE file, keep the following in mind: The schema defined in the file should be sufficient enough to prevent most configuration mistakes. If the tool being supported has rich documentation around valid values for each configuration field, use constraints to improve the accuracy of the schema. Don't be overly strict with the schema definition. The goal is to be helpful and not generate a large number of false negatives. Here is the template.nix file for our pre-commit plugin: Text Only 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #Config: { default_install_hook_types?: [...string] default_language_version?: [string]: string default_stages?: [...string] files?: string exclude?: string fail_fast?: bool minimum_pre_commit_version?: string repos: [...#Repo] } #Hook: { additional_dependencies?: [...string] alias?: string always_run?: bool args?: [...string] entry?: string exclude?: string exclude_types?: [...string] files?: string id: string language?: string language_version?: string log_file?: string name?: string stages?: [...string] types?: [...string] types_or?: [...string] verbose?: bool } #Repo: { repo: string rev?: string if repo != \"local\" { rev: string } hooks: [...#Hook] } { #Config } This file defines three definitions , notated by the # symbol. A definition can be thought of as a schema or contract. It defines the shape of valid data through various constraints. Let's break one down: Text Only 1 2 3 4 5 6 7 8 #Repo: { repo: string rev?: string if repo != \"local\" { rev: string } hooks: [...#Hook] } The pre-commit-config.yaml file has a repos field which is a list of repositories that pre-commit should build from. The #Repo definition provides the schema for these entries. Each entry must have a repo field which is a string value. The rev field is an interesting one: it's only optional if the repo field is set to \"local\". The above first sets the rev field to optional using the ? symbol and then conditonally sets it to required based on the value of repo . Finally, each entry has a list of hooks, denoted by the [...#Hooks] syntax. Text Only 1 2 3 { #Config } This final bit is where we define the actual elements of the CUE file. This is what will appear when we evaluate the CUE file. In the above case, we're saying the input data should be a struct which conforms to the schema defined by #Config . In this case, we're doing no additional transformations to the incoming data. This is because we're expecting the input data to already be in the format expected in the .pre-commit-config.yaml file. Since YAML is a superset of JSON, we can easily ask CUE to evaluate the input and produce a YAML output.","title":"Creating the CUE file"},{"location":"contributing/plugins/#creating-the-nix-functions","text":"With the CUE file created, the next step is to create our main Nix function. In this case, we're going to create a single function for generating our configuration file. Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 { pkgs , lib }: data : with pkgs . lib ; let files = [ . /template.cue ]; output = \".pre-commit-config.yaml\" ; pre-commit = pkgs . pre-commit ; # Add an extra hook for reinstalling required stages whenever the file changes stages = unique ( flatten ( builtins . map ( repo : builtins . map ( hook : optionals ( hook ? stages ) hook . stages ) repo . hooks ) data . repos ) ++ [ \"pre-commit\" ]); stagesStr = builtins . concatStringsSep \" \" stages ; shellHookExtra = ( import . /common.nix { inherit pre-commit stagesStr ; }) . shellHookExtra ; # Generate the module result = lib . mkTemplate { inherit data files output shellHookExtra ; }; in { inherit ( result ) configFile shellHook ; } All functions maintain the same basic structure. At the top we accept an attribute set as the first argument which pulls in local copies of nixpkgs and the internal lib provided by the flake. The second argument should always be named data and will contain the data passed in by the end-user. The top of the function should declare the files and output variables. The files variable should point to the CUE file we previously created. The output variable should contain the name of the configuration file the plugin is generating. Note that the extension of the configuration file is important. CUE uses the file extension to determine what format to output when our CUE file is evaluated. See here for supported formats. The remainder of the function is specific to each plugin. In the case above, we gather all of the pre-commit stages settings to determine what stages of the pre-commit process should be installed when the configuration is generated. We then create shellHookExtra which contains the necessary logic for installing the stages. At the very end, the internal mkTemplate function is called. For more details about this function, see here . In order for our plugin to be picked up by the main flake, we must take two additional steps. The first is creating a default.nix in our plugin directory that exports our function: Nix 1 2 3 4 5 6 { pkgs , lib }: { /* Creates a .pre-commit-config.yaml file for configuring pre-commit. */ mkConfig = import . /mkConfig.nix { inherit pkgs lib ; }; } This will allow the mkConfig function to be accessible under nixago.plugins.{myPlugin}.mkConfig . Finally, we must create an entry in the main default.nix : Nix 1 2 3 4 5 6 7 8 9 10 { pkgs , lib }: { # ... /* https://github.com/pre-commit/pre-commit */ pre-commit = import . /pre-commit { inherit pkgs lib ; }; # .... } This registers the plugin to make it accessible from nixago.plugins .","title":"Creating the Nix Functions"},{"location":"contributing/plugins/#writing-tests-and-documentation","text":"The final step is to write tests and documentation for the plugin. Tests are added in the tests directory in a dedicated directory named after the plugin. Tests are fairly trivial to write. The first step is to create a default.nix which runs the test: Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 { pkgs , plugins }: let output = plugins . pre-commit . mkConfig { repos = [ { repo = \"https://github.com/my/repo\" ; rev = \"1.0\" ; hooks = [ { id = \"my-hook\" ; } ]; } ]; }; result = pkgs . runCommand \"test.pre-commit\" { } '' cmp \" ${ . /expected.yml } \" \" ${ output . configFile } \" touch $out '' ; in result The test is made up of two parts: a sample configuration is generated and then it is compared to a known expected output. The test will be provided an instance of plugins in order to access functions for testing. The usage of runCommand in the second part wil necessarily build the derivation which is returned from the function. The second step is to create the expected output. In this case, the above invocation should create the following output: YAML 1 2 3 4 5 repos : - hooks : - id : my-hook repo : https://github.com/my/repo rev : \"1.0\" The generateed output will be compared to this and the test will fail if a difference is found. The final step is to add the tests to the checks output in the main flake.nix file: Nix 1 2 3 4 5 6 7 { checks = { #... pre-commit = pkgs . callPackage . /tests/pre-commit { inherit pkgs plugins ; }; #... }; } Finally, before submitting a PR, documentation should be added under the plugins section of the documentation. This should cover general usage information about the plugin including an example invocation.","title":"Writing Tests and Documentation"},{"location":"plugins/just/","text":"Just This plugin generates the .just file used by the Just task runner. It provides a single function which allows you to declare a header section and then subsequent tasks/steps. Using mkConfig Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { just = plugins . just . mkConfig { config = { head = '' var := \"value\" '' ; tasks = { task1 = [ ''echo \"Doing the thing\" '' \"@doThing\" ]; }; }; }; } The configuration has two major sections. The first is the header field which is a raw string that will be prepended to the top of the file. This is typically where global settings and variables are defined in the Justfile. The second is the tasks field which is a map of task names to a list of their respective steps. Each step in the list should ideally encompass a single action (this is idiomatic for Justfiles), however, multiline strings will also work. The above example will produce the following file contents: Text Only 1 2 3 4 5 var := \"value\" task1: echo \"Doing the thing\" @doThing","title":"Just"},{"location":"plugins/just/#just","text":"This plugin generates the .just file used by the Just task runner. It provides a single function which allows you to declare a header section and then subsequent tasks/steps.","title":"Just"},{"location":"plugins/just/#using-mkconfig","text":"Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { just = plugins . just . mkConfig { config = { head = '' var := \"value\" '' ; tasks = { task1 = [ ''echo \"Doing the thing\" '' \"@doThing\" ]; }; }; }; } The configuration has two major sections. The first is the header field which is a raw string that will be prepended to the top of the file. This is typically where global settings and variables are defined in the Justfile. The second is the tasks field which is a map of task names to a list of their respective steps. Each step in the list should ideally encompass a single action (this is idiomatic for Justfiles), however, multiline strings will also work. The above example will produce the following file contents: Text Only 1 2 3 4 5 var := \"value\" task1: echo \"Doing the thing\" @doThing","title":"Using mkConfig"},{"location":"plugins/lefthook/","text":"Lefthook This plugin generates the lefthook.yml file for configuring Lefthook . It provides a single function which allows configuring any of the valid options . Using mkConfig Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { config = { commit-msg = { scripts = { template_checker = { runner = \"bash\" ; }; }; }; pre-commit = { commands = { stylelint = { tags = \"frontend style\" ; glob = \"*.js\" ; run = \"yarn stylelint {staged_files}\" ; }; rubocop = { tags = \"backend style\" ; glob = \"*.rb\" ; exclude = \"application.rb|routes.rb\" ; run = \"bundle exec rubocop --force-exclusion {all_files}\" ; }; }; scripts = { \"good_job.js\" = { runner = \"node\" ; }; }; }; }; } Produces the following lefthook.yml : YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 commit-msg : scripts : template_checker : runner : bash pre-commit : commands : rubocop : exclude : application.rb|routes.rb glob : \"*.rb\" run : bundle exec rubocop --force-exclusion {all_files} tags : backend style stylelint : glob : \"*.js\" run : yarn stylelint {staged_files} tags : frontend style scripts : good_job.js : runner : node","title":"Lefthook"},{"location":"plugins/lefthook/#lefthook","text":"This plugin generates the lefthook.yml file for configuring Lefthook . It provides a single function which allows configuring any of the valid options .","title":"Lefthook"},{"location":"plugins/lefthook/#using-mkconfig","text":"Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 { config = { commit-msg = { scripts = { template_checker = { runner = \"bash\" ; }; }; }; pre-commit = { commands = { stylelint = { tags = \"frontend style\" ; glob = \"*.js\" ; run = \"yarn stylelint {staged_files}\" ; }; rubocop = { tags = \"backend style\" ; glob = \"*.rb\" ; exclude = \"application.rb|routes.rb\" ; run = \"bundle exec rubocop --force-exclusion {all_files}\" ; }; }; scripts = { \"good_job.js\" = { runner = \"node\" ; }; }; }; }; } Produces the following lefthook.yml : YAML 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 commit-msg : scripts : template_checker : runner : bash pre-commit : commands : rubocop : exclude : application.rb|routes.rb glob : \"*.rb\" run : bundle exec rubocop --force-exclusion {all_files} tags : backend style stylelint : glob : \"*.js\" run : yarn stylelint {staged_files} tags : frontend style scripts : good_job.js : runner : node","title":"Using mkConfig"},{"location":"plugins/overview/","text":"Overview Nixago provides most functionality through plugins. Each plugin targets a specific configuration by providing a clean interface for end-users. While most plugins follow a common schema, the varying requirements of configurations can require minor differences. Plugins can be accessed via nixago.plugins.${pluginName} . For what functions a plugin provides, see the relevant documentation page or check the source code.","title":"Overview"},{"location":"plugins/overview/#overview","text":"Nixago provides most functionality through plugins. Each plugin targets a specific configuration by providing a clean interface for end-users. While most plugins follow a common schema, the varying requirements of configurations can require minor differences. Plugins can be accessed via nixago.plugins.${pluginName} . For what functions a plugin provides, see the relevant documentation page or check the source code.","title":"Overview"},{"location":"plugins/pre-commit/","text":"Pre-commit This plugin generates the .pre-commit-config.yaml file used to configure pre-commit . It provides two functions for generating the configuration. Using mkConfig The first function follows the structure described in the docs : Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { pre-commit = nixago . plugins . pre-commit . mkConfig { config = { repos = [ { repo = \"https://github.com/my/repo\" ; rev = \"1.0\" ; hooks = [ { id = \"my-hook\" ; } ]; } ]; }; }; } The structure is validated by Cue and the derivation will fail to build if a mistake is made. The above configuration will create the following file contents: YAML 1 2 3 4 5 repos : - hooks : - id : my-hook repo : https://github.com/my/repo rev : \"1.0\" Using mkLocalConfig The second function accepts a simplified configuration format the greatly reduces the verbosity. When managing pre-commit with Nix, it's often desirable to create a single \"local\" repo entry and then add system hooks which call out to binaries in the Nix store. The benefit of this approach is that Nix manages the versioning of the binaries and you have greater control over how the hook operates. The accepted format is as follows: Nix 1 2 3 4 5 6 7 { nixpkgs-fmt = { entry = \" ${ pkgs . nixpkgs-fmt } /bin/nixpkgs-fmt\" ; language = \"system\" ; files = \" \\\\ .nix\" ; } } The format is a set consisting of hook names as the keys and their configuration properties as values. The id and name fields of the hook configuration are automatically set to the hook name (i.e., nixpkgs-fmt ). The entry should point to the binary which will be called by pre-commit. Setting language to system ensures that the entry is called with the default shell. Finally, setting files ensures that pre-commit only passes Nix files to this hook. The above configuration would produce the following pre-commit-config.yaml file: YAML 1 2 3 4 5 6 7 8 repos : - hooks : - entry : /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt files : \\.nix id : nixpkgs-fmt language : system name : nixpkgs-fmt repo : local Notice how the repos and repo properties are already set.","title":"Pre-commit"},{"location":"plugins/pre-commit/#pre-commit","text":"This plugin generates the .pre-commit-config.yaml file used to configure pre-commit . It provides two functions for generating the configuration.","title":"Pre-commit"},{"location":"plugins/pre-commit/#using-mkconfig","text":"The first function follows the structure described in the docs : Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 { pre-commit = nixago . plugins . pre-commit . mkConfig { config = { repos = [ { repo = \"https://github.com/my/repo\" ; rev = \"1.0\" ; hooks = [ { id = \"my-hook\" ; } ]; } ]; }; }; } The structure is validated by Cue and the derivation will fail to build if a mistake is made. The above configuration will create the following file contents: YAML 1 2 3 4 5 repos : - hooks : - id : my-hook repo : https://github.com/my/repo rev : \"1.0\"","title":"Using mkConfig"},{"location":"plugins/pre-commit/#using-mklocalconfig","text":"The second function accepts a simplified configuration format the greatly reduces the verbosity. When managing pre-commit with Nix, it's often desirable to create a single \"local\" repo entry and then add system hooks which call out to binaries in the Nix store. The benefit of this approach is that Nix manages the versioning of the binaries and you have greater control over how the hook operates. The accepted format is as follows: Nix 1 2 3 4 5 6 7 { nixpkgs-fmt = { entry = \" ${ pkgs . nixpkgs-fmt } /bin/nixpkgs-fmt\" ; language = \"system\" ; files = \" \\\\ .nix\" ; } } The format is a set consisting of hook names as the keys and their configuration properties as values. The id and name fields of the hook configuration are automatically set to the hook name (i.e., nixpkgs-fmt ). The entry should point to the binary which will be called by pre-commit. Setting language to system ensures that the entry is called with the default shell. Finally, setting files ensures that pre-commit only passes Nix files to this hook. The above configuration would produce the following pre-commit-config.yaml file: YAML 1 2 3 4 5 6 7 8 repos : - hooks : - entry : /nix/store/pmfl7q4fqqibkfz71lsrkcdi04m0mclf-nixpkgs-fmt-1.2.0/bin/nixpkgs-fmt files : \\.nix id : nixpkgs-fmt language : system name : nixpkgs-fmt repo : local Notice how the repos and repo properties are already set.","title":"Using mkLocalConfig"},{"location":"plugins/prettier/","text":"Prettier This plugin generates the .prettierrc.json file for configuring Prettier . It provides a single function which allows you to configure any of the valid API options . Using mkConfig The schema for the configuration file is detailed here . For example: Nix 1 2 3 4 5 6 7 { config = { arrowParens = \"always\" ; bracketSpacing = true ; tabWidth = 80 ; }; } Produces the following .prettierrc.json : JSON 1 2 3 4 5 { \"arrowParens\" : \"always\" , \"bracketSpacing\" : true , \"tabWidth\" : 80 } Overrides can be supplied that are tied to specific file formats: Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { config = { arrowParens = \"always\" ; bracketSpacing = true ; tabWidth = 80 ; overrides = [ { files = \"*.js\" ; options = { semi = true ; }; } ]; }; } Produces: JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"arrowParens\" : \"always\" , \"bracketSpacing\" : true , \"overrides\" : [ { \"files\" : \"*.js\" , \"options\" : { \"semi\" : true } } ], \"tabWidth\" : 80 }","title":"Prettier"},{"location":"plugins/prettier/#prettier","text":"This plugin generates the .prettierrc.json file for configuring Prettier . It provides a single function which allows you to configure any of the valid API options .","title":"Prettier"},{"location":"plugins/prettier/#using-mkconfig","text":"The schema for the configuration file is detailed here . For example: Nix 1 2 3 4 5 6 7 { config = { arrowParens = \"always\" ; bracketSpacing = true ; tabWidth = 80 ; }; } Produces the following .prettierrc.json : JSON 1 2 3 4 5 { \"arrowParens\" : \"always\" , \"bracketSpacing\" : true , \"tabWidth\" : 80 } Overrides can be supplied that are tied to specific file formats: Nix 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 { config = { arrowParens = \"always\" ; bracketSpacing = true ; tabWidth = 80 ; overrides = [ { files = \"*.js\" ; options = { semi = true ; }; } ]; }; } Produces: JSON 1 2 3 4 5 6 7 8 9 10 11 12 13 { \"arrowParens\" : \"always\" , \"bracketSpacing\" : true , \"overrides\" : [ { \"files\" : \"*.js\" , \"options\" : { \"semi\" : true } } ], \"tabWidth\" : 80 }","title":"Using mkConfig"}]}